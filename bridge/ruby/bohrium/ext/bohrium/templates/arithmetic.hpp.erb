#pragma once

using namespace std;

inline bool is_constant(VALUE val) {
    switch (TYPE(val)) {
        case T_DATA:
            return false;
            break;
        case T_FIXNUM:
        case T_BIGNUM:
        case T_FLOAT:
        case T_TRUE:
        case T_FALSE:
            return true;
            break;
        default:
            rb_raise(rb_eRuntimeError, "Invalid type.");
    }
}

<%
def type_converter(type)
    case type
    when "T_BIGNUM"
    when "T_FIXNUM"
        return "NUM2INT"
    when "T_FLOAT"
        return "NUM2DBL"
    when "T_TRUE"
    when "T_FALSE"
        return ""
    else
        fail "Wrong type! Got #{type}."
    end
end

# TODO: Read from opcodes.json instead.
{
    "add"      => { "int64_t" => ["T_BIGNUM", "T_FIXNUM"], "float" => ["T_FLOAT"], "bool" => ["T_TRUE", "T_FALSE"] },
    "subtract" => { "int64_t" => ["T_BIGNUM", "T_FIXNUM"], "float" => ["T_FLOAT"]                                  },
    "multiply" => { "int64_t" => ["T_BIGNUM", "T_FIXNUM"], "float" => ["T_FLOAT"], "bool" => ["T_TRUE", "T_FALSE"] },
    "divide"   => { "int64_t" => ["T_BIGNUM", "T_FIXNUM"], "float" => ["T_FLOAT"]                                  },
    "power"    => { "int64_t" => ["T_BIGNUM", "T_FIXNUM"], "float" => ["T_FLOAT"]                                  },
    "maximum"  => { "int64_t" => ["T_BIGNUM", "T_FIXNUM"], "float" => ["T_FLOAT"]                                  },
    "minimum"  => { "int64_t" => ["T_BIGNUM", "T_FIXNUM"], "float" => ["T_FLOAT"]                                  }
}.each do |m, types| %>
/**
    <%= m.capitalize %> two Bohrium arrays of type T.

    @param result The resulting array.
    @param selfObj The calling object.
    @param otherObj The other object.
*/
template <typename T>
inline void _<%= m %>(bhDataObj* result, bhDataObj* selfObj, bhDataObj* otherObj) {
    bhxx::BhArray<T> selfArray = unwrap<T>(selfObj);
    bhxx::BhArray<T> otherArray = unwrap<T>(otherObj);

    bhxx::BhArray<T>* bhary = new bhxx::BhArray<T>(selfArray.shape);
    result->ary = ((void*) bhary);

    bhxx::<%= m %>(*bhary, selfArray, otherArray);
}

template <typename T>
inline void _<%= m %>_bang(bhDataObj* selfObj, bhDataObj* otherObj) {
    bhxx::BhArray<T> selfArray = unwrap<T>(selfObj);
    bhxx::BhArray<T> otherArray = unwrap<T>(otherObj);

    bhxx::<%= m %>(selfArray, selfArray, otherArray);
}

template <typename T>
inline void _<%= m %>_constant(bhDataObj* result, bhDataObj* selfObj, T value) {
    bhxx::BhArray<T> selfArray = unwrap<T>(selfObj);

    bhxx::BhArray<T>* bhary = new bhxx::BhArray<T>(selfArray.shape);
    result->ary = ((void*) bhary);

    bhxx::<%= m %>(*bhary, selfArray, value);
}

template <typename T>
inline void _<%= m %>_constant_bang(bhDataObj* selfObj, T value) {
    bhxx::BhArray<T> selfArray = unwrap<T>(selfObj);

    bhxx::<%= m %>(selfArray, selfArray, value);
}

/**
    <%= m.capitalize %> two Bohrium arrays.

    @param self The calling object.
    @param other The other object.
    @returns The resulting array.
*/
VALUE bh_array_m_<%= m %>(VALUE self, VALUE other) {
    bhDataObj *selfObj, *otherObj;
    Data_Get_Struct(self, bhDataObj, selfObj);

    VALUE res = bh_array_alloc(RBASIC_CLASS(self));
    bhDataObj *result;
    Data_Get_Struct(res, bhDataObj, result);
    result->type = selfObj->type;

    switch (selfObj->type) {
        <% types.each do |type, ruby_types| %>
            <% ruby_types.each do |ruby_type| %>
            case <%= ruby_type %>:
                if (is_constant(other)) {
                    _<%= m %>_constant<<%= type %>>(result, selfObj, <%= type_converter(ruby_type) %>(other));
                } else {
                    Data_Get_Struct(other, bhDataObj, otherObj);
                    assert(selfObj->type == otherObj->type);
                    _<%= m %><<%= type %>>(result, selfObj, otherObj);
                }
                break;
            <% end %>
        <% end %>
        default:
            rb_raise(rb_eRuntimeError, "Wrong type for '<%= m %>'.");
    }

    return res;
}

VALUE bh_array_m_<%= m %>_bang(VALUE self, VALUE other) {
    bhDataObj *selfObj, *otherObj;
    Data_Get_Struct(self, bhDataObj, selfObj);

    switch (selfObj->type) {
        <% types.each do |type, ruby_types| %>
            <% ruby_types.each do |ruby_type| %>
            case <%= ruby_type %>:
                if (is_constant(other)) {
                    _<%= m %>_constant_bang<<%= type %>>(selfObj, <%= type_converter(ruby_type) %>(other));
                } else {
                    Data_Get_Struct(other, bhDataObj, otherObj);
                    assert(selfObj->type == otherObj->type);
                    _<%= m %>_bang<<%= type %>>(selfObj, otherObj);
                }
                break;
            <% end %>
        <% end %>
        default:
            rb_raise(rb_eRuntimeError, "Wrong type for '<%= m %>!'.");
    }

    return self;
}
<% end %>
