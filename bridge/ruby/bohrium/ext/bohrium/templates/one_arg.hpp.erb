#pragma once

#pragma push_macro("isfinite")
#undef isfinite

using namespace std;

<% @opcodes_one_arg.each do |m, hash| %>
<% types = hash[:types] %>
/**
    <%= m.capitalize %> on a Bohrium array.

    @param result The resulting array.
    @param selfObj The calling object.
*/
template <typename T>
inline void _<%= m %>(bhDataObj<T> *result, bhDataObj<T>* selfObj) {
    bhxx::BhArray<T>* selfArray = get_bhary<T>(selfObj);
    bhxx::BhArray<T>* res       = new bhxx::BhArray<T>(selfArray->shape);
    bhxx::<%= m %>(*res, *selfArray);

    result->bhary = res;
    result->type  = selfObj->type;
}

/**
    <%= m.capitalize %> on a Bohrium array.

    @param self The calling object.
    @returns The a new array.
*/
VALUE bh_array_m_<%= m %>(VALUE self) {
    UNPACK(int64_t, tmpObj);

    VALUE res = bh_array_alloc(RBASIC_CLASS(self));

    switch (tmpObj->type) {
        <% types.each do |type, ruby_types| %>
        <% ruby_types.each do |ruby_type| %>
        case <%= ruby_type %>:
        <% end %>
        {
            UNPACK(<%= type %>, selfObj);
            UNPACK_(<%= type %>, result, res);
            _<%= m %><<%= type %>>(result, selfObj);
            break;
        }
        <% end %>
        default:
            rb_raise(rb_eRuntimeError, "Wrong type.");
    }

    return res;
}

/**
    <%= m.capitalize %> on a Bohrium array.

    @param self The calling object.
*/
template <typename T>
inline void _<%= m %>_bang(bhDataObj<T>* selfObj) {
    bhxx::BhArray<T>* selfArray = get_bhary<T>(selfObj);
    bhxx::<%= m %>(*selfArray, *selfArray);
}

/**
    <%= m.capitalize %> on a Bohrium array.

    @param self The calling object.
    @returns Self.
*/
VALUE bh_array_m_<%= m %>_bang(VALUE self) {
    UNPACK(int64_t, tmpObj);

    switch (tmpObj->type) {
        <% types.each do |type, ruby_types| %>
        <% ruby_types.each do |ruby_type| %>
        case <%= ruby_type %>:
        <% end %>
        {
            UNPACK(<%= type %>, selfObj);
            _<%= m %>_bang<<%= type %>>(selfObj);
            break;
        }
        <% end %>
        default:
            rb_raise(rb_eRuntimeError, "Wrong type.");
    }

    return self;
}
<% end %>

#pragma pop_macro("isfinite")
