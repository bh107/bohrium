#include "bhxx/bhxx.hpp"
#include "bhxx/BhBase.hpp"
#include "bhxx/SVector.hpp"
#include <ruby.h>

#define F(f) reinterpret_cast<VALUE (*)(...)>(f)
#define DEBUG(msg) std::cout << "### " << msg << std::endl;
#define UNPACK(type, name) UNPACK_(type, name, self)
#define UNPACK_(type, name, s) bhDataObj<type> *name; Data_Get_Struct(s, bhDataObj<type>, name)

VALUE cBhArray;

/**
    Encapsulating struct for our Bohrium array and Ruby type.
*/
template <typename T>
struct bhDataObj {
    ruby_value_type type   = T_FIXNUM;
    bhxx::BhArray<T> bhary = nullptr;
    bhxx::BhArray<T> view  = bhary;
};

#include "util.hpp"
#include "class.hpp"
#include "one_arg.hpp"
#include "two_args.hpp"

using namespace std;

/**
    Loops through a Ruby array and initializes a Bohrium array with the same data.

    @param ary The array to use for initialization.
    @param dataObj The data object to put the initialized array into.
*/
template <typename T>
void _initialize(VALUE self, VALUE ary, ruby_value_type type) {
    UNPACK(T, dataObj);

    unsigned long size = rb_array_len(ary);
    vector<T> data_array;
    data_array.reserve(size);
    for(unsigned long i = 0; i < size; ++i) {
        data_array.push_back(_get<T>(ary, i));
    }

    shared_ptr<bhxx::BhBase> _base = bhxx::make_base_ptr(data_array.begin(), data_array.end());

    dataObj->bhary = *(new bhxx::BhArray<T>(_base, {1, size}));
    dataObj->view = dataObj->bhary;
    dataObj->type = type;
}

/**
    The BhArray#new method.

    This method creates a Bohrium array with the same data as the given Ruby array.

    @param self The object being initialized.
    @param ary The array given as argument.
    @return The new object.
*/
VALUE bh_array_m_initialize(VALUE self, VALUE ary) {
    if (rb_check_array_type(ary) == Qnil) {
        rb_raise(rb_eRuntimeError, "Data given is not an array.");
    }

    // Look at the type of the first element.
    // All elements are assumes to be of the same type.
    switch (TYPE(rb_ary_entry(ary, 0))) {
        case T_BIGNUM:
        case T_FIXNUM:
            _initialize<int64_t>(self, ary, T_FIXNUM);
            break;
        case T_FLOAT:
            _initialize<float>(self, ary, T_FLOAT);
            break;
        case T_TRUE:
        case T_FALSE:
            _initialize<bool>(self, ary, T_TRUE);
            break;
        default: {
            rb_raise(rb_eRuntimeError, "Data type not supported yet.");
            break;
        }
    }

    return self;
}

extern "C" void Init_bohrium() {
    // Define 'BhArray' class and #initialize method
    cBhArray = rb_define_class("BhArray", rb_cObject);
    rb_define_alloc_func(cBhArray, bh_array_alloc);
    rb_define_method(cBhArray, "initialize", F(bh_array_m_initialize), 1);

    // Class methods
    rb_define_singleton_method(cBhArray, "ones",   F(bh_array_s_ones),   -1);
    rb_define_singleton_method(cBhArray, "zeros",  F(bh_array_s_zeros),  -1);
    rb_define_singleton_method(cBhArray, "arange", F(bh_array_s_arange),  1);

    // Bohrium specific methods

    // `name` and `name!`, with one argument
    <% @opcodes_two_args.keys.sort.each do |name| %>
    rb_define_method(cBhArray, "<%= name %>",  F(bh_array_m_<%= name%>),      1);
    rb_define_method(cBhArray, "<%= name %>!", F(bh_array_m_<%= name%>_bang), 1);
    <% end %>

    // `name` and `name!`, but no arguments
    <% @opcodes_one_arg.keys.sort.each do |name| %>
    rb_define_method(cBhArray, "<%= name %>",  F(bh_array_m_<%= name%>),      0);
    rb_define_method(cBhArray, "<%= name %>!", F(bh_array_m_<%= name%>_bang), 0);
    <% end %>

    // `sym`
    // The `bh_array_m_"name"` methods have already been created above.
    <%
    {
        "add"      => "+",
        "subtract" => "-",
        "multiply" => "*",
        "divide"   => "/",
        "power"    => "**"
    }.each do |name, sym|
    %>
    rb_define_method(cBhArray, "<%= sym %>", F(bh_array_m_<%= name %>), 1);
    <% end %>

    // Utility methods
    rb_define_method(cBhArray, "reshape", F(bh_array_m_reshape),   1);

    rb_define_method(cBhArray, "to_s",    F(bh_array_m_to_s),   0);
    rb_define_method(cBhArray, "size",    F(bh_array_m_size),   0);
    rb_define_method(cBhArray, "shape",   F(bh_array_m_shape),  0);
    rb_define_method(cBhArray, "print",   F(bh_array_m_print),  0);
    rb_define_method(cBhArray, "to_ary",  F(bh_array_m_to_ary), 0);
    rb_define_method(cBhArray, "to_a",    F(bh_array_m_to_ary), 0);
    rb_define_method(cBhArray, "inspect", F(bh_array_m_to_ary), 0);
    rb_define_method(cBhArray, "type",    F(bh_array_m_type),   0);

    rb_define_private_method(cBhArray, "view_from_ranges", F(bh_array_m_view_from_ranges), -1);
    rb_define_private_method(cBhArray, "set_from_ranges",  F(bh_array_m_set_from_ranges),  -1);
}
