#include "bhxx/bhxx.hpp"
#include "bhxx/BhBase.hpp"
#include "bhxx/SVector.hpp"
#include <ruby.h>

#define F(f) reinterpret_cast<VALUE (*)(...)>(f)
#define DEBUG(msg) std::cout << "### " << msg << std::endl;
#define UNPACK(type, name) UNPACK_(type, name, self)
#define UNPACK_(type, name, s) bhDataObj<type> *name; Data_Get_Struct(s, bhDataObj<type>, name)

VALUE cBhArray;

/**
    Encapsulating struct for our Bohrium array and Ruby type.
*/
template <typename T>
struct bhDataObj {
    ruby_value_type type    = T_FIXNUM;
    bhDataObj<T>* parent    = nullptr;
    bhxx::BhArray<T>* bhary = nullptr;
    uint32_t bhary_version  = 0;
    bhxx::BhArray<T>* view  = nullptr;
    uint32_t view_version   = 0;
};

#include "util.hpp"
#include "class.hpp"
#include "one_arg.hpp"
#include "two_args.hpp"
#include "two_args_constant.hpp"
#include "two_args_boolean_result.hpp"

using namespace std;

/**
    Loops through a Ruby array and initializes a Bohrium array with the same data.

    @param ary The array to use for initialization.
    @param dataObj The data object to put the initialized array into.
*/
template <typename T>
void _initialize(VALUE self, VALUE ary, ruby_value_type type) {
    UNPACK(T, dataObj);

    unsigned long size = rb_array_len(ary);
    vector<T> data_array;
    data_array.reserve(size);
    for(unsigned long i = 0; i < size; ++i) {
        data_array.push_back(_get<T>(ary, i));
    }

    shared_ptr<bhxx::BhBase> _base = bhxx::make_base_ptr(data_array.begin(), data_array.end());

    // TODO: For now we only allow one-dimensional input
    dataObj->bhary = new bhxx::BhArray<T>(_base, {size});
    dataObj->type  = type;
}

/**
    The BhArray#new method.

    This method creates a Bohrium array with the same data as the given Ruby array.

    @param self The object being initialized.
    @param ary The array given as argument.
    @return The new object.
*/
VALUE bh_array_m_initialize(VALUE self, VALUE ary) {
    if (rb_check_array_type(ary) == Qnil) {
        rb_raise(rb_eRuntimeError, "Data given is not an array.");
    }

    // Look at the type of the first element.
    // All elements are assumes to be of the same type.
    switch (TYPE(rb_ary_entry(ary, 0))) {
        case T_BIGNUM:
        case T_FIXNUM:
            _initialize<int64_t>(self, ary, T_FIXNUM);
            break;
        case T_FLOAT:
            _initialize<float>(self, ary, T_FLOAT);
            break;
        case T_TRUE:
        case T_FALSE:
            _initialize<bool>(self, ary, T_TRUE);
            break;
        default: {
            rb_raise(rb_eRuntimeError, "Data type not supported yet.");
            break;
        }
    }

    return self;
}

extern "C" void Init_bohrium() {
    VALUE mBohrium = rb_define_module("Bohrium");
    rb_define_module_function(mBohrium, "flush", F(bh_flush), 0);

    // Define 'BhArray' class and #initialize method
    cBhArray = rb_define_class("BhArray", rb_cObject);
    rb_define_alloc_func(cBhArray, bh_array_alloc);
    rb_define_method(cBhArray, "initialize", F(bh_array_m_initialize), 1);

    // Class methods
    rb_define_singleton_method(cBhArray, "ones",   F(bh_array_s_ones),   -1);
    rb_define_singleton_method(cBhArray, "zeros",  F(bh_array_s_zeros),  -1);
    rb_define_singleton_method(cBhArray, "random", F(bh_array_s_random), -1);
    rb_define_singleton_method(cBhArray, "arange", F(bh_array_s_arange),  1);
    rb_define_singleton_method(cBhArray, "seq",    F(bh_array_s_arange),  1); // Not an alias, since it's a singleton method

    // Bohrium specific methods
    <% @opcodes_two_args_boolean_result.keys.sort.each do |name| %>
    rb_define_method(cBhArray, "<%= name %>",  F(bh_array_m_<%= name%>),      1);
    <% end %>

    // `name` and `name!`, with one argument
    <% @opcodes_two_args_constant.keys.sort.each do |name| %>
    rb_define_method(cBhArray, "<%= name %>",  F(bh_array_m_<%= name%>),      1);
    <% end %>

    <% @opcodes_two_args.keys.sort.each do |name| %>
    rb_define_method(cBhArray, "<%= name %>",  F(bh_array_m_<%= name%>),      1);
    rb_define_method(cBhArray, "<%= name %>!", F(bh_array_m_<%= name%>_bang), 1);
    <% end %>

    // `name` and `name!`, but no arguments
    <% @opcodes_one_arg.keys.sort.each do |name| %>
    rb_define_method(cBhArray, "<%= name %>",  F(bh_array_m_<%= name%>),      0);
    rb_define_method(cBhArray, "<%= name %>!", F(bh_array_m_<%= name%>_bang), 0);
    <% end %>

    // `sym`
    // The `bh_array_m_"name"` methods have already been created above.
    <%
    {
        "add"           => "+",
        "subtract"      => "-",
        "multiply"      => "*",
        "divide"        => "/",
        "power"         => "**",

        "less"          => "<",
        "less_equal"    => "<=",
        "greater"       => ">",
        "greater_equal" => ">=",
        "equal"         => "==",
        "not_equal"     => "!=",
        "logical_and"   => "&&",
        "logical_or"    => "||"
    }.each do |name, sym|
    %>
    rb_define_method(cBhArray, "<%= sym %>", F(bh_array_m_<%= name %>), 1);
    <% end %>

    // Utility methods
    rb_define_method(cBhArray, "reshape", F(bh_array_m_reshape),   1);

    rb_define_method(cBhArray, "to_s",    F(bh_array_m_to_s),   0);
    rb_define_method(cBhArray, "size",    F(bh_array_m_size),   0);
    rb_define_method(cBhArray, "shape",   F(bh_array_m_shape),  0);
    rb_define_method(cBhArray, "print",   F(bh_array_m_print),  0);
    rb_define_method(cBhArray, "type",    F(bh_array_m_type),   0);
    rb_define_method(cBhArray, "to_ary",  F(bh_array_m_to_ary), 0);

    rb_define_alias(cBhArray, "to_a", "to_ary");
    rb_define_alias(cBhArray, "inspect", "to_ary");

    rb_define_private_method(cBhArray, "view_from_ranges", F(bh_array_m_view_from_ranges), -1);
    rb_define_private_method(cBhArray, "set_from_ranges",  F(bh_array_m_set_from_ranges),  -1);
}
