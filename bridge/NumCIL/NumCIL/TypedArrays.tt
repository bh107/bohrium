#region Copyright
/*
This file is part of Bohrium and copyright (c) 2012 the Bohrium
team <http://www.bh107.org>.

Bohrium is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as 
published by the Free Software Foundation, either version 3 
of the License, or (at your option) any later version.

Bohrium is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the 
GNU Lesser General Public License along with Bohrium. 

If not, see <http://www.gnu.org/licenses/>.
*/
#endregion

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<#
foreach(string fulltypename in new string[] {"System.SByte", "System.Byte", "System.Int16", "System.UInt16", "System.Int32", "System.UInt32", "System.Int64", "System.UInt64", "System.Single", "System.Double", "System.Boolean", "System.Numerics.Complex", "NumCIL.Complex64.DataType"})
{
	string typename = fulltypename;
	string mathlib = "Math";

	switch (typename)
	{
		case "System.Single":
			typename = "Float";
			break;
		case "System.SByte":
			typename = "Int8";
			break;
		case "System.Byte":
			typename = "UInt8";
			break;
		case "System.Numerics.Complex":
			typename = "Complex128";
			mathlib = "T";
			break;
		case "NumCIL.Complex64.DataType":
			typename = "Complex64";
			mathlib = "T";
			break;
		default:
			if (typename.StartsWith("System."))
				typename = typename.Substring("System.".Length);
			break;
	}
#>

namespace NumCIL.<#=typename#>
{
    using T = <#=fulltypename#>;
    using InArray = NumCIL.Generic.NdArray<<#=fulltypename#>>;
    using OutArray = NdArray;

    /// <summary>
    /// A wrapper for a basic NdArray to a similar one with typed operators
    /// </summary>
    public partial class NdArray : IEnumerable<InArray>
    {
        #region NdArray Mimics
        /// <summary>
        /// The value instance that gives access to values
        /// </summary>
        public InArray.ValueAccessor Value { get { return value.Value; } }
        /// <summary>
        /// A reference to the shape instance that describes this view
        /// </summary>
        public Shape Shape { get { return value.Shape; } }
        /// <summary>
        /// A reference to the underlying data storage
        /// </summary>
        public T[] AsArray() { return value.AsArray(); }
        /// <summary>
        /// Gets a subview on the array
        /// </summary>
        /// <param name="index">The element to get the view from</param>
        /// <returns>A view on the selected element</returns>
        public OutArray this[params long[] index] { get { return this.value[index]; } set { this.value[index] = value; } }
        /// <summary>
        /// Gets a subview on the array
        /// </summary>
        /// <param name="ranges">The range get the view from</param>
        /// <returns>A view on the selected element</returns>
        public OutArray this[params Range[] ranges] { get { return this.value[ranges]; } set { this.value[ranges] = value; } }
        /// <summary>
        /// Returns a flattened (1-d copy) of the current data view
        /// </summary>
        /// <returns>A flattened copy</returns>
        public OutArray Flatten() { return this.value.Flatten(); }
        /// <summary>
        /// Returns a copy of the underlying data, shaped as this view
        /// </summary>
        /// <returns>A copy of the view data</returns>
        public OutArray Clone() { return this.value.Clone(); }
        /// <summary>
        /// Generates a new view based on this array
        /// </summary>
        /// <param name="newshape">The new shape</param>
        /// <returns>The reshaped array</returns>
        public OutArray Reshape(Shape newshape) { return this.value.Reshape(newshape); }
        /// <summary>
        /// Returns a view that is a view of a single element
        /// </summary>
        /// <param name="element">The element to view</param>
        /// <returns>The subview</returns>
        public OutArray Subview(long element) { return this.value.Subview(element); }
        /// <summary>
        /// Returns a view that is a view of a range of elements
        /// </summary>
        /// <param name="range">The range to view</param>
        /// <param name="dimension">The dimension to view</param>
        /// <returns>The subview</returns>
        public OutArray Subview(Range range, long dimension) { return this.value.Subview(range, dimension); }
        /// <summary>
        /// Returnes a sliced subview of the data, optionally collapsing single element dimensions
        /// </summary>
        /// <param name="ranges">The ranges to view for each dimension</param>
        /// <param name="collapse">True if single element dimensions should be collapsed, false to retain all dimensions</param>
        /// <returns>A new view of the data</returns>
        public OutArray Subview(Range[] ranges, bool collapse) { return this.value.Subview(ranges, collapse); }
        /// <summary>
        /// Returns an enumerator that iterates through a collection.
        /// </summary>
        /// <returns>
        /// An <see cref="T:System.Collections.Generic.IEnumerator"/> object that can be used to iterate through the collection.
        /// </returns>
        public IEnumerator<InArray> GetEnumerator() { return this.value.GetEnumerator(); }
        /// <summary>
        /// Returns an enumerator that iterates through a collection.
        /// </summary>
        /// <returns>
        /// An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
        /// </returns>
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() { return this.value.GetEnumerator(); }
        /// <summary>
        /// A debug tag used for naming a view
        /// </summary>
        public string Name { get { return this.value.Name; } set { this.value.Name = value; } }
        /// <summary>
        /// The data accessor providing the data storage
        /// </summary>
        public NumCIL.Generic.IDataAccessor<T> DataAccessor { get { return this.value.DataAccessor; } }

        /// <summary>
        /// Constructs a NdArray that is a scalar wrapper,
        /// allows simple scalar operations on arbitrary
        /// NdArrays
        /// </summary>
        /// <param name="value">The scalar value</param>
        public NdArray(T value)
            : this(new NumCIL.Generic.DefaultAccessor<T>(new T[] { value }))
        {
        }

        /// <summary>
        /// Constructs a new NdArray with the specified shape
        /// </summary>
        /// <param name="shape">The shape of the new NdArray</param>
        public NdArray(Shape shape)
            : this(Generate.Empty(shape))
        {
        }

        /// <summary>
        /// Constructs a new NdArray over a pre-allocated array and shapes it
        /// </summary>
        /// <param name="data">The data to wrap in a NdArray</param>
        /// <param name="shape">The shape to view the array in</param>
        public NdArray(T[] data, Shape shape = null)
            : this(new InArray(data, shape))
        {
        }

        /// <summary>
        /// Constructs a new NdArray over a pre-allocated array and shapes it
        /// </summary>
        /// <param name="data">The data to wrap in a NdArray</param>
        /// <param name="shape">The shape to view the array in</param>
        public NdArray(NumCIL.Generic.IDataAccessor<T> data, Shape shape = null)
            : this(new InArray(data, shape))
        {
        }

        /// <summary>
        /// Constructs a new NdArray over a pre-allocated array and shapes it
        /// </summary>
        /// <param name="source">An existing array that will be re-shaped</param>
        /// <param name="newshape">The shape to view the array in</param>
        public NdArray(InArray source, Shape newshape)
            : this(new InArray(source, newshape))
        {
        }

        /// <summary>
        /// Returns a <see cref="System.String"/> that represents this instance.
        /// </summary>
        /// <returns>
        /// A <see cref="System.String"/> that represents this instance.
        /// </returns>
        public override string ToString()
        {
            return this.value.ToString();
        }

        /// <summary>
        /// Flushes pending operations on the array
        /// </summary>
        public void Flush() { this.value.Flush(); }

        /// <summary>
        /// Returns a transposed view of this array. If <paramref name="out"/> is supplied, the contents are copied into that array.
        /// </summary>
        /// <param name="out">Optional output array</param>
        /// <returns>A transposed view</returns>
        public OutArray Transpose(OutArray @out = null) { return value.Transpose(@out); }

        /// <summary>
        /// Gets or sets data in a transposed view
        /// </summary>
        public OutArray Transposed { get { return value.Transposed; } set { value.Transposed = this.value; } }

        /// <summary>
        /// Repeats elements of the array
        /// </summary>
        /// <param name="repeats">The number of repeats to perform</param>
        /// <param name="axis">The axis to repeat, if not speficied, repeat is done on a flattened array</param>
        /// <returns>A repeated copy of the input data</returns>
        public OutArray Repeat(long repeats, long? axis = null) { return value.Repeat(repeats, axis); }

        /// <summary>
        /// Repeats elements of the array
        /// </summary>
        /// <param name="repeats">The number of repeats to perform in each axis</param>
        /// <param name="axis">The axis to repeat, if not specified, repeat is done on a flattened array</param>
        /// <returns>A repeated copy of the input data</returns>
        public OutArray Repeat(long[] repeats, long? axis = null) { return value.Repeat(repeats, axis); }

        /// <summary>
        /// Concatenates an array onto this array, joined at the axis
        /// </summary>
        /// <param name="arg">The array to join</param>
        /// <param name="axis">The axis to join at</param>
        /// <returns>The joined array</returns>
        public OutArray Concatenate(OutArray arg, long axis = 0) { return this.value.Concatenate(arg, axis); }

        /// <summary>
        /// Sets the values viewed to the values from another array, i.e. copies the values
        /// </summary>
        /// <param name="arg">The data to copy</param>
        public void Set(OutArray arg) { this.value.Set(arg); }
        #endregion

        /// <summary>
        /// The only data member of the struct is a reference to the underlying view
        /// </summary>
        private readonly InArray value;
        /// <summary>
        /// Constructs a new typed array from a basic one
        /// </summary>
        /// <param name="v">The basic array</param>
        public NdArray(InArray v) { this.value = v; }

        #region Implict conversion operators
        /// <summary>
        /// Implicit operator that returns a typed array from a basic one
        /// </summary>
        /// <param name="v">The basic array to wrap</param>
        /// <returns>A wrapped array</returns>
        public static implicit operator OutArray(InArray v) { return v == null ? null : new OutArray(v); }
        /// <summary>
        /// Implicit operator that returns a basic array from a wrapped one
        /// </summary>
        /// <param name="v">The wrapper array</param>
        /// <returns>The basic array</returns>
        public static implicit operator InArray(NdArray v) { return ((object)v) == null ? null : v.value; }
        /// <summary>
        /// Implicit operator that returns a wrapped array from a scalar value
        /// </summary>
        /// <param name="v">The scalar value</param>
        /// <returns>A wrapped array representing the scalar value</returns>
        public static implicit operator OutArray(T v) { return new OutArray(v); }
        #endregion

<# if (!fulltypename.StartsWith("System.Boolean")) { #>
        #region Operator implementations
        /// <summary>
        /// Calculates addition to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of adding the two input operands</returns>
        public static OutArray operator +(OutArray a, OutArray b) { return UFunc.Apply<T, Add>(a, b, null); }
        /// <summary>
        /// Calculates subtraction of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of subtracting the two input operands</returns>
        public static OutArray operator -(OutArray a, OutArray b) { return UFunc.Apply<T, Sub>(a, b, null); }
<# if (typename[0] != 'U') { #>
        /// <summary>
        /// Calculates negation of the operand
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of subtracting the two input operands</returns>
        public static OutArray operator -(OutArray a) { return UFunc.Apply<T, Sub>(new OutArray((T)0), a, null); }
<# } #>
        /// <summary>
        /// Calculates multiplication to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of multiplying the two input operands</returns>
        public static OutArray operator *(OutArray a, OutArray b) { return UFunc.Apply<T, Mul>(a, b, null); }
        /// <summary>
        /// Calculates division of to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of dividing the two input operands</returns>
        public static OutArray operator /(OutArray a, OutArray b) { return UFunc.Apply<T, Div>(a, b, null); }
<# if (!typename.StartsWith("Complex")) { #>
        /// <summary>
        /// Calculates modulo of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The modulo result of dividing the two input operands</returns>
        public static OutArray operator %(OutArray a, OutArray b) { return UFunc.Apply<T, Mod>(a, b, null); }
<# } #>

        /// <summary>
        /// Calculates the incremented value of the operand
        /// </summary>
        /// <param name="a">An input operand</param>
        /// <returns>The result of incrementing each value</returns>
        public static OutArray operator ++(OutArray a) { return UFunc.Apply<T, Add>(a, (OutArray)1, null); }
        /// <summary>
        /// Calculates the decremented value of the operand
        /// </summary>
        /// <param name="a">An input operand</param>
        /// <returns>The result of decrementing each value</returns>
        public static OutArray operator --(OutArray a) { return UFunc.Apply<T, Sub>(a, (OutArray)1, null); }
        #endregion

        #region Common function implementations
        /// <summary>
        /// Copies all values from this NdArray to the output NdArray
        /// </summary>
        /// <param name="out">Optional target for addition, if null, a new array is created</param>
        /// <returns>An NdArray which is a copy of this array</returns>
        public OutArray Copy(OutArray @out = null) { return UFunc.Apply<T, NumCIL.CopyOp<T>>(this, @out); }
        /// <summary>
        /// Adds the values of an NdArray to this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to add</param>
        /// <param name="out">Optional target for addition, use to perform in-place addition</param>
        /// <returns>An NdArray which is the result of adding the two NdArrays</returns>
        public OutArray Add(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Add>(this, op, @out); }
        /// <summary>
        /// Subtracts the values of an NdArray from this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to subtract</param>
        /// <param name="out">Optional target for addition, use to perform in-place subtraction</param>
        /// <returns>An NdArray which is the result of subtracting the two NdArrays</returns>
        public OutArray Sub(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Sub>(this, op, @out); }
        /// <summary>
        /// Multiplies the values of an NdArray to this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to multiply with</param>
        /// <param name="out">Optional target for multiplication, use to perform in-place multiplication</param>
        /// <returns>An NdArray which is the result of multiplying the two NdArrays</returns>
        public OutArray Mul(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Mul>(this, op, @out); }
        /// <summary>
        /// Divides the values of an NdArray with this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to divide with</param>
        /// <param name="out">Optional target for division, use to perform in-place division</param>
        /// <returns>An NdArray which is the result of dividing the two NdArrays</returns>
        public OutArray Div(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Div>(this, op, @out); }
<# if (!typename.StartsWith("Complex")) { #>
        /// <summary>
        /// Divides values of an NdArray with this NdArray and returns the modulo result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to divide with</param>
        /// <param name="out">Optional target for modulo result, use to perform in-place modulo</param>
        /// <returns>An NdArray which is the modulo residues of dividing the two NdArrays</returns>
        public OutArray Mod(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Mod>(this, op, @out); }
        /// <summary>
        /// Calculates the maximum values of each element in two NdArrays and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to compare with</param>
        /// <param name="out">Optional target for the max operation, use to perform in-place maximum calculation</param>
        /// <returns>An NdArray which is the maximum values of the two NdArrays</returns>
        public OutArray Max(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Max>(this, op, @out); }
        /// <summary>
        /// Calculates the minimum values of each element in two NdArrays and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to compare with</param>
        /// <param name="out">Optional target for the min operation, use to perform in-place minimum calculation</param>
        /// <returns>An NdArray which is the minimum values of the two NdArrays</returns>
        public OutArray Min(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Min>(this, op, @out); }

<# if (!typename.StartsWith("U") && !typename.StartsWith("I")) { #>
        /// <summary>
        /// Returns a new NdArray that is the result of rounding up all the elements in this NdArray to the nearest integer
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with all values rounded up to the nearest integer</returns>
        public OutArray Ceiling(OutArray @out = null) { return UFunc.Apply<T, Ceiling>(this, @out); }
        /// <summary>
        /// Returns a new NdArray that is the result of rounding down all the elements in this NdArray to the nearest integer
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with all values rounded down to the nearest integer</returns>
        public OutArray Floor(OutArray @out = null) { return UFunc.Apply<T, Floor>(this, @out); }
        /// <summary>
        /// Returns a new NdArray that is the result of rounding all the elements in this NdArray to the nearest integer
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with all values rounded to the nearest integer</returns>
        public OutArray Round(OutArray @out = null) { return UFunc.Apply<T, Round>(this, @out); }
<# } #>
<# } #>
        /// <summary>
        /// Returns a new NdArray that is the result of calculating the square root for all the elements in this NdArray
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with the square root of all values</returns>
        public OutArray Sqrt(OutArray @out = null) { return UFunc.Apply<T, Sqrt>(this, @out); }
        /// <summary>
        /// Returns a new NdArray that is the result of calculating the exponent for all the elements in this NdArray
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with the exponent of all values</returns>
        public OutArray Exp(OutArray @out = null) { return UFunc.Apply<T, Exp>(this, @out); }
<# if (typename[0] != 'U') { #>
        /// <summary>
        /// Returns a new NdArray that has the absolute value of all elements in this array
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with all absolute values</returns>
        public OutArray Abs(OutArray @out = null) { return UFunc.Apply<T, Abs>(this, @out); }
<# } #>
        /// <summary>
        /// Returns a new NdArray that is the result of calculating the logarithmic value of all the elements in this NdArray
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with the logarithmic of all values</returns>
        public OutArray Log(OutArray @out = null) { return UFunc.Apply<T, Log>(this, @out); }
        /// <summary>
        /// Returns a new NdArray that is the result of calculating the logarithmic-10 value of all the elements in this NdArray
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with the logarithmic-10 of all values</returns>
        public OutArray Log10(OutArray @out = null) { return UFunc.Apply<T, Log10>(this, @out); }
        /// <summary>
        /// Calculates each element in this NdArray as being raised to the power of the mathcing element in the operand NdArray
        /// </summary>
        /// <param name="op">The power-of values</param>
        /// <param name="out">Optional target for the pow operation, use to perform in-place power-of calculation</param>
        /// <returns>An NdArray which is the values of this NdArray raised to the power of the values in the operand NdArray</returns>
        public OutArray Pow(NdArray op, OutArray @out = null) { return UFunc.Apply<T, Pow>(this, op, @out); }
        /// <summary>
        /// Calculates each element in this NdArray as being raised to the power of the scalar value
        /// </summary>
        /// <param name="value">The power-of value</param>
        /// <param name="out">Optional target for the pow operation, use to perform in-place power-of calculation</param>
        /// <returns>An NdArray which is the values of this NdArray raised to the power of the scalar value</returns>
        public OutArray Pow(T value, OutArray @out = null)
        {
            if (value == 2)
                return UFunc.Apply<T, Mul>(this, this, @out);
            else
                return UFunc.Apply<T, Pow>(this, (OutArray)value, @out);
        }
        /// <summary>
        /// Performs matrix multiplication on the two elements
        /// </summary>
        /// <param name="arg">The right-hand-side argument in matrix multiplication</param>
        /// <param name="out">Optional target for the multiplication</param>
        /// <returns>The matrix multiplication result</returns>
        public OutArray MatrixMultiply(OutArray arg, OutArray @out = null) { return UFunc.Matmul<T, Add, Mul>(this, arg, @out); }
        #endregion
<# } #>


        #region F# support for missing implicit operators
<# if (!fulltypename.StartsWith("System.Boolean")) { #>
        /// <summary>
        /// Calculates addition to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of adding the two input operands</returns>
        public static OutArray operator +(T a, OutArray b) { return UFunc.Apply<T, Add>((OutArray)a, b, null); }
        /// <summary>
        /// Calculates addition to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of adding the two input operands</returns>
        public static OutArray operator +(OutArray a, T b) { return UFunc.Apply<T, Add>(a, (OutArray)b, null); }
        /// <summary>
        /// Calculates subtraction of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of subtracting the two input operands</returns>
        public static OutArray operator -(T a, OutArray b) { return UFunc.Apply<T, Sub>((OutArray)a, b, null); }
        /// <summary>
        /// Calculates subtraction of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of subtracting the two input operands</returns>
        public static OutArray operator -(OutArray a, T b) { return UFunc.Apply<T, Sub>(a, (OutArray)b, null); }
        /// <summary>
        /// Calculates multiplication to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of multiplying the two input operands</returns>
        public static OutArray operator *(T a, OutArray b) { return UFunc.Apply<T, Mul>((OutArray)a, b, null); }
        /// <summary>
        /// Calculates multiplication to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of multiplying the two input operands</returns>
        public static OutArray operator *(OutArray a, T b) { return UFunc.Apply<T, Mul>(a, (OutArray)b, null); }
        /// <summary>
        /// Calculates division of to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of dividing the two input operands</returns>
        public static OutArray operator /(T a, OutArray b) { return UFunc.Apply<T, Div>((OutArray)a, b, null); }
        /// <summary>
        /// Calculates division of to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of dividing the two input operands</returns>
        public static OutArray operator /(OutArray a, T b) { return UFunc.Apply<T, Div>(a, (OutArray)b, null); }
<# if (!typename.StartsWith("Complex")) { #>
        /// <summary>
        /// Calculates modulo of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The modulo result of dividing the two input operands</returns>
        public static OutArray operator %(T a, OutArray b) { return UFunc.Apply<T, Mod>((OutArray)a, b, null); }
        /// <summary>
        /// Calculates modulo of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The modulo result of dividing the two input operands</returns>
        public static OutArray operator %(OutArray a, T b) { return UFunc.Apply<T, Mod>(a, (OutArray)b, null); }
<# } #>

        /// <summary>
        /// Adds the values of an NdArray to this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to add</param>
        /// <param name="out">Optional target for addition, use to perform in-place addition</param>
        /// <returns>An NdArray which is the result of adding the two NdArrays</returns>
        public OutArray Add(T op, OutArray @out = null) { return UFunc.Apply<T, Add>(this, (OutArray)op, @out); }
        /// <summary>
        /// Subtracts the values of an NdArray from this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to subtract</param>
        /// <param name="out">Optional target for addition, use to perform in-place subtraction</param>
        /// <returns>An NdArray which is the result of subtracting the two NdArrays</returns>
        public OutArray Sub(T op, OutArray @out = null) { return UFunc.Apply<T, Sub>(this, (OutArray)op, @out); }
        /// <summary>
        /// Multiplies the values of an NdArray to this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to multiply with</param>
        /// <param name="out">Optional target for multiplication, use to perform in-place multiplication</param>
        /// <returns>An NdArray which is the result of multiplying the two NdArrays</returns>
        public OutArray Mul(T op, OutArray @out = null) { return UFunc.Apply<T, Mul>(this, (OutArray)op, @out); }
        /// <summary>
        /// Divides the values of an NdArray with this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to divide with</param>
        /// <param name="out">Optional target for division, use to perform in-place division</param>
        /// <returns>An NdArray which is the result of dividing the two NdArrays</returns>
        public OutArray Div(T op, OutArray @out = null) { return UFunc.Apply<T, Div>(this, (OutArray)op, @out); }
<# } #>

        /// <summary>
        /// Compares the operands and returns a value indicating if a equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator ==(T a, OutArray b) { return UFunc.Apply<T, bool, Equal>((OutArray)a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator ==(OutArray a, T b) { return UFunc.Apply<T, bool, Equal>(a, (OutArray)b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is not equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator !=(T a, OutArray b) { return UFunc.Apply<T, bool, NotEqual>((OutArray)a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is not equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator !=(OutArray a, T b) { return UFunc.Apply<T, bool, NotEqual>(a, (OutArray)b, null); }

<# if (!typename.StartsWith("Complex") && fulltypename != "System.Boolean") {	#>
        /// <summary>
        /// Compares the operands and returns a value indicating if a is greater than b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator >(T a, OutArray b) { return UFunc.Apply<T, bool, GreaterThan>((OutArray)a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is greater than b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator >(OutArray a, T b) { return UFunc.Apply<T, bool, GreaterThan>(a, (OutArray)b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is less than b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator <(T a, OutArray b) { return UFunc.Apply<T, bool, LessThan>((OutArray)a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is less than b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator <(OutArray a, T b) { return UFunc.Apply<T, bool, LessThan>(a, (OutArray)b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is greater than or equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator >=(T a, OutArray b) { return UFunc.Apply<T, bool, GreaterThanOrEqual>((OutArray)a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is greater than or equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator >=(OutArray a, T b) { return UFunc.Apply<T, bool, GreaterThanOrEqual>(a, (OutArray)b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is less than or equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator <=(T a, OutArray b) { return UFunc.Apply<T, bool, LessThanOrEqual>((OutArray)a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is less than or equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator <=(OutArray a, T b) { return UFunc.Apply<T, bool, LessThanOrEqual>(a, (OutArray)b, null); }
<# } #>
        #endregion

        #region Appliers for custom UFuncs
        /// <summary>
        /// Applies a unary lambda function to each element in this NdArray
        /// </summary>
        /// <param name="op">The lamda function to apply</param>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>An NdArray that is the result of applying the lambda function to each element</returns>
        public OutArray Apply(Func<T, T> op, OutArray @out = null) { return UFunc.Apply(op, this, @out); }
        /// <summary>
        /// Applies a binary lambda function to each element in this NdArray
        /// </summary>
        /// <param name="op">The lamda function to apply</param>
        /// <param name="b">An input operand</param>
        /// <returns>An NdArray that is the result of applying the lambda function to each element</returns>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        public OutArray Apply(Func<T, T, T> op, OutArray b, OutArray @out = null) { return UFunc.Apply<T>(op, this, b, @out); }
        /// <summary>
        /// Applies a unary function to each element in this NdArray
        /// </summary>
        /// <typeparam name="C">The function to apply</typeparam>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>An NdArray that is the result of applying the function to each element</returns>
        public OutArray Apply<C>(OutArray @out = null) where C : struct, IUnaryOp<T> { return UFunc.Apply<T, C>(this, @out); }
        /// <summary>
        /// Applies a binary function to each element in this NdArray
        /// </summary>
        /// <typeparam name="C">The function to apply</typeparam>
        /// <param name="b">An input operand</param>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>An NdArray that is the result of applying the function to each element</returns>
        public OutArray Apply<C>(OutArray b, OutArray @out = null) where C : struct, IBinaryOp<T> { return UFunc.Apply<T, C>(this, b, @out); }
        /// <summary>
        /// Applies a nullary function to each element in this NdArray
        /// Note that Nullary functions are performed in-place
        /// </summary>
        /// <param name="op">The function to apply</param>
        /// <returns>This NdArray</returns>
        public OutArray Apply(INullaryOp<T> op) { UFunc.Apply<T>(op, this); return this; }
        /// <summary>
        /// Applies a unary function to each element in this NdArray
        /// </summary>
        /// <param name="op">The function to apply</param>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>An NdArray that is the result of applying the function to each element</returns>
        public OutArray Apply(IUnaryOp<T> op, OutArray @out = null) { return UFunc.Apply<T>(op, this, @out); }
        /// <summary>
        /// Applies a binary function to each element in this NdArray
        /// </summary>
        /// <param name="op">The function to apply</param>
        /// <param name="b">An input operand</param>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>An NdArray that is the result of applying the function to each element</returns>
        public OutArray Apply(IBinaryOp<T> op, OutArray b, OutArray @out = null) { return UFunc.Apply<T>(op, this, b, @out); }

        /// <summary>
        /// Performs a reduction operation on this array
        /// </summary>
        /// <typeparam name="C">The function to apply reduction with</typeparam>
        /// <param name="axis">The axis to remove</param>
        /// <param name="out">An optional output array, use this to perform the reduction in-place</param>
        /// <returns>An NdArray that is the result of reducing the selected axis</returns>
        public OutArray Reduce<C>(long axis = 0, OutArray @out = null) where C : struct, IBinaryOp<T> { return UFunc.Reduce<T, C>(this, axis, @out); }
        /// <summary>
        /// Performs a reduction operation on this array
        /// </summary>
        /// <param name="op">The function to apply reduction with</param>
        /// <param name="axis">The axis to remove</param>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>A reduced array</returns>
        public OutArray Reduce(IBinaryOp<T> op, long axis = 0, OutArray @out = null) { return UFunc.Reduce<T>(op, this, axis, @out); }

        /// <summary>
        /// Calculates the scalar result of applying the binary operation to all elements
        /// </summary>
        /// <typeparam name="C">The operation to perform</typeparam>
        /// <returns>A scalar value that is the result of aggregating all elements</returns>
        public T Aggregate<C>() where C : struct, IBinaryOp<T> { return UFunc.Aggregate<T, C>(this); }

        /// <summary>
        /// Calculates the scalar result of applying the binary operation to all elements
        /// </summary>
        /// <param name="op">The operation to perform</param>
        /// <returns>A scalar value that is the result of aggregating all elements</returns>
        public T Aggregate(IBinaryOp<T> op) { return UFunc.Aggregate<T>(op, this); }

<# if (!fulltypename.StartsWith("System.Boolean")) { #>
        /// <summary>
        /// Calculates the sum of all elements
        /// </summary>
        /// <returns>A scalar value that is the sum of all elements</returns>
        public T Sum() { return UFunc.Aggregate<T, Add>(this); }
<# if (!typename.StartsWith("Complex")) { #>
        /// <summary>
        /// Calculates the maximum of all elements
        /// </summary>
        /// <returns>A scalar value that is the maximum of all elements</returns>
        public T Max() { return UFunc.Aggregate<T, Max>(this); }

        /// <summary>
        /// Calculates the minimum of all elements
        /// </summary>
        /// <returns>A scalar value that is the minimum of all elements</returns>
        public T Min() { return UFunc.Aggregate<T, Min>(this); }
<# } #>
<# } #>
        #endregion

<# if (!typename.StartsWith("Complex") && fulltypename != "System.Boolean" ) { #>
		#region Conversion operators
        <# 
		if (fulltypename != "System.Double") 
		{ 
		#>/// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Double"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Double"/></returns>
        public static implicit operator OutArray(NumCIL.Double.NdArray a) { return UFunc.Apply<double, T, To<#=typename#>>(a); }
        <# 
		}
		
		if (fulltypename != "System.Single") 
		{ 
		#>/// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Single"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Single"/></returns>
<# if (fulltypename == "System.Double") { #>
        public static explicit operator OutArray(NumCIL.Float.NdArray a) { return UFunc.Apply<float, T, To<#=typename#>>(a); }
<# } else { #>
        public static implicit operator OutArray(NumCIL.Float.NdArray a) { return UFunc.Apply<float, T, To<#=typename#>>(a); }
<# } #>
        <# 
		} 
		
		if (fulltypename != "System.SByte") 
		{ 
		#>/// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.SByte"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.SByte"/></returns>
        public static explicit operator OutArray(NumCIL.Int8.NdArray a) { return UFunc.Apply<sbyte, T, To<#=typename#>>(a); }
        <# 
		} 
		
		if (fulltypename != "System.Int16") 
		{ 
		#>/// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Int16"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Int16"/></returns>
<# if (fulltypename == "System.SByte" || fulltypename == "System.Byte") { #>
        public static implicit operator OutArray(NumCIL.Int16.NdArray a) { return UFunc.Apply<short, T, To<#=typename#>>(a); }
<# } else { #>
        public static explicit operator OutArray(NumCIL.Int16.NdArray a) { return UFunc.Apply<short, T, To<#=typename#>>(a); }
<# } #>
        <# 
		} 
		
		if (fulltypename != "System.Int32") 
		{ 
		#>/// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Int32"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Int32"/></returns>
<# if (fulltypename == "System.SByte" || fulltypename == "System.Byte" || fulltypename == "System.Int16" || fulltypename == "System.UInt16") { #>
        public static implicit operator OutArray(NumCIL.Int32.NdArray a) { return UFunc.Apply<int, T, To<#=typename#>>(a); }
<# } else { #>
        public static explicit operator OutArray(NumCIL.Int32.NdArray a) { return UFunc.Apply<int, T, To<#=typename#>>(a); }
<# } #>
        <# 
		} 
		
		if (fulltypename != "System.Int64") 
		{
		#>/// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Int64"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Int64"/></returns>
<# if (fulltypename == "System.SByte" || fulltypename == "System.Byte" || fulltypename == "System.Int16" || fulltypename == "System.UInt16" || fulltypename == "System.Int32" || fulltypename == "System.UInt32") { #>
        public static implicit operator OutArray(NumCIL.Int64.NdArray a) { return UFunc.Apply<long, T, To<#=typename#>>(a); }
<# } else { #>
        public static explicit operator OutArray(NumCIL.Int64.NdArray a) { return UFunc.Apply<long, T, To<#=typename#>>(a); }
<# } #>
        <#
		}
		if (fulltypename != "System.Byte") 
		{ 
		#>/// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Byte"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Byte"/></returns>
        public static explicit operator OutArray(NumCIL.UInt8.NdArray a) { return UFunc.Apply<byte, T, To<#=typename#>>(a); }
        <# 
		}
		
		if (fulltypename != "System.UInt16") 
		{ 
		#>/// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.UInt16"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.UInt16"/></returns>
<# if (fulltypename == "System.Byte") { #>
        public static implicit operator OutArray(NumCIL.UInt16.NdArray a) { return UFunc.Apply<ushort, T, To<#=typename#>>(a); }
<# } else { #>
        public static explicit operator OutArray(NumCIL.UInt16.NdArray a) { return UFunc.Apply<ushort, T, To<#=typename#>>(a); }
<# } #>
        <# 
		}
		
		if (fulltypename != "System.UInt32") 
		{ 
		#>/// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.UInt32"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.UInt32"/></returns>
<# if ( fulltypename == "System.Byte" || fulltypename == "System.UInt16") { #>
        public static implicit operator OutArray(NumCIL.UInt32.NdArray a) { return UFunc.Apply<uint, T, To<#=typename#>>(a); }
<# } else { #>
        public static explicit operator OutArray(NumCIL.UInt32.NdArray a) { return UFunc.Apply<uint, T, To<#=typename#>>(a); }
<# } #>
        <# 
		}
		
		if (fulltypename != "System.UInt64") 
		{
		#>/// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.UInt64"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.UInt64"/></returns>
<# if ( fulltypename == "System.Byte" || fulltypename == "System.UInt16" || fulltypename == "System.UInt32") { #>
        public static implicit operator OutArray(NumCIL.UInt64.NdArray a) { return UFunc.Apply<ulong, T, To<#=typename#>>(a); }
<# } else { #>
        public static explicit operator OutArray(NumCIL.UInt64.NdArray a) { return UFunc.Apply<ulong, T, To<#=typename#>>(a); }
<# } #>
		<# } #>
		#endregion
<# } #>

<# if (!typename.StartsWith("Complex") && fulltypename != "System.Single" && fulltypename != "System.Double") {	#>
		#region Logical/Bitwise operator overloads
        /// <summary>
        /// Calculates the and of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of and-ing the two input operands</returns>
        public static OutArray operator &(OutArray a, OutArray b) { return UFunc.Apply<T, And>(a, b, null); }
        /// <summary>
        /// Calculates the or of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of or-ing the two input operands</returns>
        public static OutArray operator |(OutArray a, OutArray b) { return UFunc.Apply<T, Or>(a, b, null); }
        /// <summary>
        /// Calculates the xor of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of xor-ing the two input operands</returns>
        public static OutArray operator ^(OutArray a, OutArray b) { return UFunc.Apply<T, Xor>(a, b, null); }
<# if (fulltypename == "System.Boolean") { #>
        /// <summary>
        /// Calculates the logical negation of the operand
        /// </summary>
        /// <param name="a">An input operand</param>
        /// <returns>The logical negation of the input operand</returns>
        public static OutArray operator !(OutArray a) { return UFunc.Apply<T, Not>(a, null); }
<# } else { #>
        /// <summary>
        /// Calculates the bitwise complement of the operand
        /// </summary>
        /// <param name="a">An input operand</param>
        /// <returns>The bitwise complement of the input operand</returns>
        public static OutArray operator !(OutArray a) { return UFunc.Apply<T, Invert>(a, null); }
<# } #>
		#endregion
<# } #>

		#region Comparison operator overloads
        /// <summary>
        /// Compares the operands and returns a value indicating if a equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator ==(OutArray a, OutArray b) { return UFunc.Apply<T, bool, Equal>(a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static bool operator ==(OutArray a, object b) { return ((object)a) == b; }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is not equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator !=(OutArray a, OutArray b) { return UFunc.Apply<T, bool, NotEqual>(a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static bool operator !=(OutArray a, object b) { return ((object)a) != b; }
<# if (!typename.StartsWith("Complex") && fulltypename != "System.Boolean") {	#>
        /// <summary>
        /// Compares the operands and returns a value indicating if a is greater than b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator >(OutArray a, OutArray b) { return UFunc.Apply<T, bool, GreaterThan>(a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is less than b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator <(OutArray a, OutArray b) { return UFunc.Apply<T, bool, LessThan>(a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is greater than or equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator >=(OutArray a, OutArray b) { return UFunc.Apply<T, bool, GreaterThanOrEqual>(a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is less than or equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator <=(OutArray a, OutArray b) { return UFunc.Apply<T, bool, LessThanOrEqual>(a, b, null); }
<# } #>
		#endregion

		#region System.Object overrides
		/// <summary>
		/// Compares this object to another
		/// </summary>
		/// <returns>A value indicating if the two elements are equal</returns>
		public override bool Equals(object o)
		{
			return this == o;
		}

		/// <summary>
		/// Returns a hashcode for comparing this object to others
		/// </summary>
		/// <returns>A hash code for this instance</returns>
		public override int GetHashCode()
		{
			return value.GetHashCode();
		}
		#endregion
    }

    #region Struct instances for common operations
    /// <summary>
    /// Collection of instantiated operation structs
    /// </summary>
    public partial struct Ops
    {
        /// <summary>
        /// The addition operation
        /// </summary>
        public static readonly CopyOp<T> Copy;
<# if (fulltypename != "System.Boolean") { #>
        /// <summary>
        /// The addition operation
        /// </summary>
        public static readonly Add Add;
        /// <summary>
        /// The subtraction operation
        /// </summary>
        public static readonly Sub Sub;
        /// <summary>
        /// The multiplication operation
        /// </summary>
        public static readonly Mul Mul;
        /// <summary>
        /// The division operation
        /// </summary>
        public static readonly Div Div;
<# if (!typename.StartsWith("Complex")) { #>
        /// <summary>
        /// The modulo operation
        /// </summary>
        public static readonly Mod Mod;
        /// <summary>
        /// The maximum operation
        /// </summary>
        public static readonly Max Max;
        /// <summary>
        /// The minimum operation
        /// </summary>
        public static readonly Min Min;
<# if (!typename.StartsWith("U") && !typename.StartsWith("I")) { #>
        /// <summary>
        /// The floor operation
        /// </summary>
        public static readonly Floor Floor;
        /// <summary>
        /// The ceiling operation
        /// </summary>
        public static readonly Ceiling Ceiling;
        /// <summary>
        /// The round operation
        /// </summary>
        public static readonly Round Round;
<# } #>
<# } #>
<# if (typename[0] != 'U') { #>
        /// <summary>
        /// The absolute operation
        /// </summary>
        public static readonly Abs Abs;
<# } #>
        /// <summary>
        /// The square root operation
        /// </summary>
        public static readonly Sqrt Sqrt;
        /// <summary>
        /// The exponential operation
        /// </summary>
        public static readonly Exp Exp;
        /// <summary>
        /// The logarithmic operation
        /// </summary>
        public static readonly Log Log;
        /// <summary>
        /// The logarithmic-10 operation
        /// </summary>
        public static readonly Log10 Log10;
        /// <summary>
        /// The power operation
        /// </summary>
        public static readonly Pow Pow;
        /// <summary>
        /// The arc cosine operation
        /// </summary>
        public static readonly Acos Acos;
        /// <summary>
        /// The arc sine operation
        /// </summary>
        public static readonly Asin Asin;
        /// <summary>
        /// The arc tangent operation
        /// </summary>
        public static readonly Atan Atan;
        /// <summary>
        /// The cosine operation
        /// </summary>
        public static readonly Cos Cos;
        /// <summary>
        /// The sine operation
        /// </summary>
        public static readonly Sin Sin;
        /// <summary>
        /// The tangent operation
        /// </summary>
        public static readonly Tan Tan;
        /// <summary>
        /// The hyperbolic cosine operation
        /// </summary>
        public static readonly Cosh Cosh;
        /// <summary>
        /// The hyperbolic sine operation
        /// </summary>
        public static readonly Sinh Sihn;
        /// <summary>
        /// The hyperbolic tangent operation
        /// </summary>
        public static readonly Tanh Tanh;
<# } #>
<# if (!typename.StartsWith("Complex") && fulltypename != "System.Single" && fulltypename != "System.Double") { #>
        /// <summary>
        /// The and operation
        /// </summary>
        public static readonly And And;
        /// <summary>
        /// The or operation
        /// </summary>
        public static readonly Or Or;
        /// <summary>
        /// The xor operation
        /// </summary>
        public static readonly Xor Xor;
<# if (fulltypename == "System.Boolean") { #>       
        /// <summary>
        /// The invert operation
        /// </summary>
        public static readonly Not Not;
<# } else { #>
        /// <summary>
        /// The invert operation
        /// </summary>
        public static readonly Invert Invert;
<# } #>

<# } #>
    }
    #endregion

	#region Comparison operators
<# 
foreach(var opname in new string[] {"Equal", "GreaterThan", "LessThan", "GreaterThanOrEqual", "LessThanOrEqual", "NotEqual"}) { 
	if (opname != "Equal" && opname != "NotEqual" && (typename.StartsWith("Complex") || fulltypename == "System.Boolean")) {
		continue;
	}
#>
    /// <summary>
    /// The equal <#=opname#> implementation
    /// </summary>
    public struct <#=opname#> : IBinaryCompareOp<T>, NumCIL.Generic.Operators.I<#=opname#>
    {
        /// <summary>
        /// Implementation of <#=opname#> test
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>Elementwise result of the comparison</returns>
		public bool Op(T a, T b)
		<# if (opname == "Equal") { #>{ return a == b; }
		<# } else if (opname == "GreaterThan") { #>{ return a > b; }
		<# } else if (opname == "LessThan") { #>{ return a < b; }
		<# } else if (opname == "GreaterThanOrEqual") { #>{ return a >= b; }
		<# } else if (opname == "LessThanOrEqual") { #>{ return a <= b; }
		<# } else if (opname == "NotEqual") { #>{ return a != b; }
		<# } #>

        /// <summary>
        /// Applies the <#=opname#> operation to the input operands
        /// </summary>
        /// <param name="in1">An input operand</param>
        /// <param name="in2">An input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise compare of the input view</returns>
        public static NumCIL.Boolean.NdArray Apply(OutArray in1, OutArray in2, NumCIL.Boolean.NdArray @out = null)
        { return UFunc.Apply<T, bool, <#=opname#>>(in1, in2, @out); }
    }

<# } #>
	#endregion

    #region Operator implementations
    /// <summary>
    /// The copy operator implementation
    /// </summary>
    public struct Copy
    {
        /// <summary>
        /// Applies the copy operation to the input operand
        /// </summary>
        /// <param name="in1">The input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise copy of the input view</returns>
        public static OutArray Apply(OutArray in1, OutArray @out = null)
        { return UFunc.Apply<T, NumCIL.CopyOp<T>>(in1, @out); }
    }

	#region Binary operation implementations
<# 
//Binary operations
foreach(var opname in new string[] {"Add", "Sub", "Mul", "Div", "Mod", "Min", "Max", "Pow", "And", "Or", "Xor"}) {

	if (typename.StartsWith("Complex") && (opname == "Mod" || opname == "Min" || opname == "Max" || opname == "And" || opname == "Or" || opname == "Xor"))
		continue;

	if (fulltypename == "System.Boolean" && opname != "And" && opname != "Or" && opname != "Xor")
		continue;
		
	if ((fulltypename == "System.Single" || fulltypename == "System.Double") && (opname == "And" || opname == "Or" || opname == "Xor"))
		continue;

#>
    /// <summary>
    /// The <#=opname#> operator implementation
    /// </summary>
    public struct <#=opname#> : IBinaryOp<T>, NumCIL.Generic.Operators.I<#=opname#>
    {
        /// <summary>
        /// Implementation of <#=opname#> with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of <#=opname#> with two numbers</returns>
        public T Op(T a, T b)
		<#        if (opname == "Add") { #>{ return (T)(a + b); }
		<# } else if (opname == "Sub") { #>{ return (T)(a - b); }
		<# } else if (opname == "Mul") { #>{ return (T)(a * b); }
		<# } else if (opname == "Div") { #>{ return (T)(a / b); }
		<# } else if (opname == "Mod") { #>{ return (T)(a % b); }
		<# } else if (opname == "Max") { #>{ return (T)Math.Max(a, b); }
		<# } else if (opname == "Min") { #>{ return (T)Math.Min(a, b); }
		<# } else if (opname == "Pow") { #>{ return (T)<#=mathlib#>.Pow(a, b); }
		<# } else if (opname == "And") { #>{ return (T)(a & b); }
		<# } else if (opname == "Or") { #>{ return (T)(a | b); }
		<# } else if (opname == "Xor") { #>{ return (T)(a ^ b); }
		<# } #>

        /// <summary>
        /// Reduces the input array with the <#=opname#> operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, <#=opname#>>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the <#=opname#> operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, <#=opname#>>(arg); }

        /// <summary>
        /// Applies the <#=opname#> operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, <#=opname#>>(in1, in2, @out); }

        /// <summary>
        /// Applies the <#=opname#> operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, <#=opname#>>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the <#=opname#> operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		<# if (opname == "Pow") { #>{ 
			if (in2 == (T)2)
				return UFunc.Apply<T, Mul>(in1, in1, @out);
			else
				return UFunc.Apply<T, Pow>(in1, (OutArray)in2, @out);
		}
		<# } else { #>{ return UFunc.Apply<T, <#=opname#>>(in1, (OutArray)in2, @out); }<# } #>

    }

<# } #>
	#endregion

	#region Unary operations implementation
<#
foreach(var opname in new string[] {"Ceiling", "Floor", "Round", "Sqrt", "Exp", "Abs", "Sin", "Cos", "Tan", "Asin", "Acos", "Atan", "Sinh", "Cosh", "Tanh", "Log", "Log10", "Invert", "Not", "Sign"}) 
{
	if (opname == "Not" && fulltypename != "System.Boolean")
		continue;

	if (fulltypename == "System.Boolean" && opname != "Not")
		continue;

	if ((opname == "Ceiling" || opname == "Floor" || opname == "Round" || opname == "Not" || opname == "Invert" || opname == "Sign") && typename.StartsWith("Complex"))
		continue;

	if ((opname == "Abs" || opname == "Sign") && typename.StartsWith("U"))
		continue;

	if ((opname == "Round" || opname == "Ceiling" || opname == "Floor") && (typename.StartsWith("U") || typename.StartsWith("I")))
		continue;

	if ((fulltypename == "System.Single" || fulltypename == "System.Double") && (opname == "Not" || opname == "Invert"))
		continue;
#>
    /// <summary>
    /// The <#=opname#> operation implementation
    /// </summary>
    public struct <#=opname#> : IUnaryOp<T>, NumCIL.Generic.Operators.I<#=opname#>
    {
        /// <summary>
        /// Implementation of the <#=opname#> operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying <#=opname#> to the operand</returns>
        public T Op(T a) 
		<#        if (opname == "Ceiling") { #>{ return (T)Math.Ceiling(a); }
		<# } else if (opname == "Floor")   { #>{ return (T)Math.Floor(a); }
		<# } else if (opname == "Round")   { #>{ return (T)Math.Round(a); }
		<# } else if (opname == "Sqrt")    { #>{ return (T)<#=mathlib#>.Sqrt(a); }
		<# } else if (opname == "Exp")     { #>{ return (T)<#=mathlib#>.Exp(a); }
		<# } else if (opname == "Abs")     { #>{ return (T)<#=mathlib#>.Abs(a); }
		<# } else if (opname == "Sin")     { #>{ return (T)<#=mathlib#>.Sin(a); }
		<# } else if (opname == "Cos")     { #>{ return (T)<#=mathlib#>.Cos(a); }
		<# } else if (opname == "Tan")     { #>{ return (T)<#=mathlib#>.Tan(a); }
		<# } else if (opname == "Asin")    { #>{ return (T)<#=mathlib#>.Asin(a); }
		<# } else if (opname == "Acos")    { #>{ return (T)<#=mathlib#>.Acos(a); }
		<# } else if (opname == "Atan")    { #>{ return (T)<#=mathlib#>.Atan(a); }
		<# } else if (opname == "Sinh")    { #>{ return (T)<#=mathlib#>.Sinh(a); }
		<# } else if (opname == "Cosh")    { #>{ return (T)<#=mathlib#>.Cosh(a); }
		<# } else if (opname == "Tanh")    { #>{ return (T)<#=mathlib#>.Tanh(a); }
		<# } else if (opname == "Log")     { #>{ return (T)<#=mathlib#>.Log(a); }
		<# } else if (opname == "Log10")   { #>{ return (T)<#=mathlib#>.Log10(a); }
		<# } else if (opname == "Sign")    { #>{ return (T)<#=mathlib#>.Sign(a); }
		<# } else if (opname == "Invert")  { #>{ return (T)(~a); }
		<# } else if (opname == "Not")     { #>{ return (T)(!a); }
		<# } #>

        /// <summary>
        /// Applies the <#=opname#> operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, <#=opname#>>(@in, @out); }

        /// <summary>
        /// Applies the <#=opname#> operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, <#=opname#>>((OutArray)@in, @out); }
    }

<# } #>
	#endregion
	#endregion

    #region Generate mimics
    /// <summary>
    /// Generates basic initial arrays
    /// </summary>
    public static class Generate
    {
        /// <summary>
        /// The factory class that produces the NdArray instances
        /// </summary>
        public static NumCIL.Generic.IGenerator<T> Generator = new NumCIL.Generic.Generator<T, NumCIL.Generic.RandomGeneratorOp<#=typename#>, NumCIL.Generic.RangeGeneratorOp<T, NumCIL.Generic.NumberConverter<#=typename#>>, NumCIL.Generic.NumberConverter<#=typename#>>();

        /// <summary>
        /// Creates a range sequential integers, starting with zero
        /// </summary>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with sequential numbers</returns>
        public static OutArray Range(Shape shape) { return Generator.Range(shape); }
        /// <summary>
        /// Creates an array filled with the value 1
        /// </summary>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with all values set to 1</returns>
        public static OutArray Ones(Shape shape) { return Generator.Ones(shape); }
        /// <summary>
        /// Creates an array filled with the value 0
        /// </summary>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with all values set to 0</returns>
        public static OutArray Zeroes(Shape shape) { return Generator.Zeroes(shape); }
        /// <summary>
        /// Creates an uninitialized array
        /// </summary>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with uninitialized data</returns>
        public static OutArray Empty(Shape shape) { return Generator.Empty(shape); }
        /// <summary>
        /// Creates an array filled with the given value
        /// </summary>
        /// <param name="value">The value to fill the array with</param>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with all values set to the given value</returns>
        public static OutArray Same(T value, Shape shape) { return Generator.Same(value, shape); }
        /// <summary>
        /// Creates an array filled with the value random numbers
        /// </summary>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with all values set to random numbers</returns>
        public static OutArray Random(Shape shape) { return Generator.Random(shape); }

        /// <summary>
        /// Creates a range sequential integers, starting with zero
        /// </summary>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with sequential numbers</returns>
        public static OutArray Range(params long[] dimensions) { return Generator.Range(dimensions); }
        /// <summary>
        /// Creates an array filled with the value 1
        /// </summary>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with all values set to 1</returns>
        public static OutArray Ones(params long[] dimensions) { return Generator.Ones(dimensions); }
        /// <summary>
        /// Creates an array filled with the value 0
        /// </summary>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with all values set to 0</returns>
        public static OutArray Zeroes(params long[] dimensions) { return Generator.Zeroes(dimensions); }
        /// <summary>
        /// Creates an uninitialized array
        /// </summary>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with uninitialized values</returns>
        public static OutArray Empty(params long[] dimensions) { return Generator.Empty(dimensions); }
        /// <summary>
        /// Creates an array filled with the given value
        /// </summary>
        /// <param name="value">The value to set fill the array with</param>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with all values set to the given value</returns>
        public static OutArray Same(T value, params long[] dimensions) { return Generator.Same(value, dimensions); }
        /// <summary>
        /// Creates an array filled with random values
        /// </summary>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with all values set to a random value</returns>
        public static OutArray Random(params long[] dimensions) { return Generator.Random(dimensions); }
    }
    #endregion

<# if (!typename.StartsWith("Complex") && fulltypename != "System.Boolean") { #>
	#region Conversion operator
	/// <summary>
    /// Operator for converting a number to another type
    /// </summary>
	public struct To<#=typename#> :
<#   if (fulltypename != "System.Double") { #>        IUnaryConvOp<double, T>, 
<# } if (fulltypename != "System.Single") { #>        IUnaryConvOp<float, T>, 
<# } if (fulltypename != "System.SByte")  { #>        IUnaryConvOp<sbyte, T>, 
<# } if (fulltypename != "System.Byte")   { #>        IUnaryConvOp<byte,T>, 
<# } if (fulltypename != "System.Int16")  { #>        IUnaryConvOp<short, T>, 
<# } if (fulltypename != "System.UInt16") { #>        IUnaryConvOp<ushort, T>, 
<# } if (fulltypename != "System.Int32")  { #>        IUnaryConvOp<int, T>, 
<# } if (fulltypename != "System.UInt32") { #>        IUnaryConvOp<uint,T>, 
<# } if (fulltypename != "System.Int64")  { #>        IUnaryConvOp<long, T>, 
<# } if (fulltypename != "System.UInt64") { #>        IUnaryConvOp<ulong, T>,
<# } #>
		NumCIL.Generic.Operators.ITypeConversion
    {

<#   if (fulltypename != "System.Double") { #>
        /// <summary>
        /// Converts the input from a <see cref="System.Double"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(double a) { return (T)a; }
<# } if (fulltypename != "System.Single") { #>
        /// <summary>
        /// Converts the input from a <see cref="System.Single"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(float a) { return (T)a; }
<# } if (fulltypename != "System.SByte") { #>
        /// <summary>
        /// Converts the input from a <see cref="System.SByte"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(sbyte a) { return (T)a; }
<# } if (fulltypename != "System.Byte") { #>
        /// <summary>
        /// Converts the input from a <see cref="System.Byte"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(byte a) { return (T)a; }
<# } if (fulltypename != "System.UInt16") { #>
        /// <summary>
        /// Converts the input from a <see cref="System.UInt16"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(ushort a) { return (T)a; }
<# } if (fulltypename != "System.Int16") { #>
        /// <summary>
        /// Converts the input from a <see cref="System.Int16"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(short a) { return (T)a; }
<# } if (fulltypename != "System.UInt32") { #>
        /// <summary>
        /// Converts the input from a <see cref="System.UInt32"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(uint a) { return (T)a; }
<# } if (fulltypename != "System.Int32") { #>
        /// <summary>
        /// Converts the input from a <see cref="System.Int32"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(int a) { return (T)a; }
<# } if (fulltypename != "System.UInt64") { #>
        /// <summary>
        /// Converts the input from a <see cref="System.UInt64"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(ulong a) { return (T)a; }
<# } if (fulltypename != "System.Int64") { #>
        /// <summary>
        /// Converts the input from a <see cref="System.Int64"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(long a) { return (T)a; }
<# } #>
    }
	#endregion
<# } #>
}
<#
}
#>

<#
foreach(string typename in new string[] {"Complex128", "Complex64"})
{

string datatype = typename == "Complex128" ? "System.Numerics.Complex" : "NumCIL.Complex64.DataType";
string componenttype = typename == "Complex128" ? "System.Double" : "System.Single";
string ndarraytype = typename == "Complex128" ? "NumCIL.Double.NdArray" : "NumCIL.Float.NdArray";

#>

namespace NumCIL.<#=typename#>
{
    using T = <#=datatype#>;
    using OutArray = NumCIL.Generic.NdArray<<#=datatype#>>;
    using InArray = NumCIL.<#=typename#>.NdArray;
	using TComp = <#=componenttype#>;
	using TCompArray = <#=ndarraytype#>;

    /// <summary>
    /// A wrapper for a basic NdArray to a similar one with typed operators
    /// </summary>
    public partial class NdArray
    {
        #region Conversion operators
        /// <summary>
        /// Converts all elements in the input NdArray from <see cref="System.Double"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="<#=datatype#>"/></returns>
<# if (typename == "Complex64") { #>
        public static explicit operator InArray(NumCIL.Double.NdArray a) { return UFunc.Apply<double, T, ToComplex>(a); }
<# } else { #>
        public static implicit operator InArray(NumCIL.Double.NdArray a) { return UFunc.Apply<double, T, ToComplex>(a); }
<# } #>
        /// <summary>
        /// Converts all elements in the input NdArray from <see cref="System.Single"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="<#=datatype#>"/></returns>
        public static implicit operator InArray(NumCIL.Float.NdArray a) { return UFunc.Apply<float, T, ToComplex>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray from <see cref="System.SByte"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="<#=datatype#>"/></returns>
        public static implicit operator InArray(NumCIL.Int8.NdArray a) { return UFunc.Apply<sbyte, T, ToComplex>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray from <see cref="System.Byte"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="<#=datatype#>"/></returns>
        public static implicit operator InArray(NumCIL.UInt8.NdArray a) { return UFunc.Apply<byte, T, ToComplex>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray from <see cref="System.UInt16"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="<#=datatype#>"/></returns>
        public static implicit operator InArray(NumCIL.UInt16.NdArray a) { return UFunc.Apply<ushort, T, ToComplex>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray from <see cref="System.Int16"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="<#=datatype#>"/></returns>
        public static implicit operator InArray(NumCIL.Int16.NdArray a) { return UFunc.Apply<short, T, ToComplex>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray from <see cref="System.UInt32"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="<#=datatype#>"/></returns>
        public static implicit operator InArray(NumCIL.UInt32.NdArray a) { return UFunc.Apply<uint, T, ToComplex>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray from <see cref="System.Int32"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="<#=datatype#>"/></returns>
        public static implicit operator InArray(NumCIL.Int32.NdArray a) { return UFunc.Apply<int, T, ToComplex>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray from <see cref="System.UInt64"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="<#=datatype#>"/></returns>
        public static implicit operator InArray(NumCIL.UInt64.NdArray a) { return UFunc.Apply<ulong, T, ToComplex>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray from <see cref="System.Int64"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="<#=datatype#>"/></returns>
        public static implicit operator InArray(NumCIL.Int64.NdArray a) { return UFunc.Apply<long, T, ToComplex>(a); }

<# if (typename == "Complex64") { #>
        /// <summary>
        /// Converts all elements in the input NdArray from <see cref="<#=datatype#>"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="NumCIL.Complex64.DataType"/></returns>
        public static explicit operator InArray(NumCIL.Complex128.NdArray a) { return UFunc.Apply<System.Numerics.Complex, T, ToComplex>(a); }
<# } else { #>
        /// <summary>
        /// Converts all elements in the input NdArray from <see cref="NumCIL.Complex64.DataType"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="<#=datatype#>"/></returns>
        public static implicit operator InArray(NumCIL.Complex64.NdArray a) { return UFunc.Apply<NumCIL.Complex64.DataType, T, ToComplex>(a); }
<# } #>

        #endregion

		#region Scalar conversion operators
        /// <summary>
        /// Converts a scalar from <see cref="System.Double"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="<#=datatype#>"/></returns>
<# if (typename == "Complex64") { #>
        public static explicit operator InArray(double a) { return UFunc.Apply<double, T, ToComplex>((NumCIL.Double.NdArray)a); }
<# } else { #>
        public static implicit operator InArray(double a) { return UFunc.Apply<double, T, ToComplex>((NumCIL.Double.NdArray)a); }
<# } #>
        /// <summary>
        /// Converts a scalar from <see cref="System.Double"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="<#=datatype#>"/></returns>
<# if (typename == "Complex64") { #>
        public static explicit operator InArray(System.Numerics.Complex a) { return UFunc.Apply<System.Numerics.Complex, T, ToComplex>((NumCIL.Complex128.NdArray)a); }
<# } else { #>
        public static implicit operator InArray(NumCIL.Complex64.DataType a) { return UFunc.Apply<NumCIL.Complex64.DataType, T, ToComplex>((NumCIL.Complex64.NdArray)a); }
<# } #>
        /// <summary>
        /// Converts  scalar from <see cref="System.Single"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="<#=datatype#>"/></returns>
        public static implicit operator InArray(float a) { return UFunc.Apply<float, T, ToComplex>((NumCIL.Float.NdArray)a); }
        /// <summary>
        /// Converts a scalar from <see cref="System.SByte"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="<#=datatype#>"/></returns>
        public static implicit operator InArray(sbyte a) { return UFunc.Apply<sbyte, T, ToComplex>((NumCIL.Int8.NdArray)a); }
        /// <summary>
        /// Converts a scalar from <see cref="System.Byte"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="<#=datatype#>"/></returns>
        public static implicit operator InArray(byte a) { return UFunc.Apply<byte, T, ToComplex>((NumCIL.UInt8.NdArray)a); }
        /// <summary>
        /// Converts a scalar from <see cref="System.UInt16"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="<#=datatype#>"/></returns>
        public static implicit operator InArray(ushort a) { return UFunc.Apply<ushort, T, ToComplex>((NumCIL.UInt16.NdArray)a); }
        /// <summary>
        /// Converts a scalar from <see cref="System.Int16"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="<#=datatype#>"/></returns>
        public static implicit operator InArray(short a) { return UFunc.Apply<short, T, ToComplex>((NumCIL.Int16.NdArray)a); }
        /// <summary>
        /// Converts a scalar from <see cref="System.UInt32"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="<#=datatype#>"/></returns>
        public static implicit operator InArray(uint a) { return UFunc.Apply<uint, T, ToComplex>((NumCIL.UInt32.NdArray)a); }
        /// <summary>
        /// Converts a scalar NdArray from <see cref="System.Int32"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="<#=datatype#>"/></returns>
        public static implicit operator InArray(int a) { return UFunc.Apply<int, T, ToComplex>((NumCIL.Int32.NdArray)a); }
        /// <summary>
        /// Converts a scalar from <see cref="System.UInt64"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="<#=datatype#>"/></returns>
        public static implicit operator InArray(ulong a) { return UFunc.Apply<ulong, T, ToComplex>((NumCIL.UInt64.NdArray)a); }
        /// <summary>
        /// Converts a scalar from <see cref="System.Int64"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="<#=datatype#>"/></returns>
        public static implicit operator InArray(long a) { return UFunc.Apply<long, T, ToComplex>((NumCIL.Int64.NdArray)a); }		
		#endregion

        #region Complex conversion operators
        /// <summary>
        /// Returns a new NdArray that has the real component value of all elements in this array
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with all real component values</returns>
        public TCompArray Real(<#=ndarraytype#> @out = null) { return UFunc.Apply<T, TComp, Real>(this, @out); }
        /// <summary>
        /// Returns a new NdArray that has the imaginary component value of all elements in this array
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with all imaginary component values</returns>
        public TCompArray Imaginary(<#=ndarraytype#> @out = null) { return UFunc.Apply<T, TComp, Imaginary>(this, @out); }
        /// <summary>
        /// Returns a new NdArray that has the magnitude component value of all elements in this array
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with all magnitude component values</returns>
        public TCompArray Magnitude(<#=ndarraytype#> @out = null) { return UFunc.Apply<T, TComp, Magnitude>(this, @out); }
        /// <summary>
        /// Returns a new NdArray that has the phase component value of all elements in this array
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with all phase component values</returns>
        public TCompArray Phase(<#=ndarraytype#> @out = null) { return UFunc.Apply<T, TComp, Phase>(this, @out); }
        /// <summary>
        /// Returns a new NdArray that has the conjugate value of all elements in this array
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with all conjugate values</returns>
        public OutArray Phase(OutArray @out = null) { return UFunc.Apply<T, Conjugate>(this, @out); }

        #endregion
    }

    #region Struct instances for common operations
    /// <summary>
    /// Collection of instantiated operation structs
    /// </summary>
    public partial struct Ops
    {
        /// <summary>
        /// The real operation
        /// </summary>
        public static readonly Real Real;
        /// <summary>
        /// The imaginary operation
        /// </summary>
        public static readonly Imaginary Imaginary;
        /// <summary>
        /// The magnitude operation
        /// </summary>
        public static readonly Magnitude Magnitude;
        /// <summary>
        /// The phase operation
        /// </summary>
        public static readonly Phase Phase;
        /// <summary>
        /// The conjugate operation
        /// </summary>
        public static readonly Conjugate Conjugate;
    }
    #endregion

    #region Conversion operators
    /// <summary>
    /// Operator for converting a value to complex number
    /// </summary>
    public struct ToComplex : 
<# if (typename == "Complex64") { #>
		IUnaryConvOp<System.Numerics.Complex, T>, 
<# } else { #>
		IUnaryConvOp<NumCIL.Complex64.DataType, T>, 
<# } #>
        IUnaryConvOp<double, T>, 
        IUnaryConvOp<float, T>, 
        IUnaryConvOp<sbyte, T>, 
        IUnaryConvOp<byte,T>, 
        IUnaryConvOp<short, T>, 
        IUnaryConvOp<ushort, T>, 
        IUnaryConvOp<int, T>, 
        IUnaryConvOp<uint,T>, 
        IUnaryConvOp<long, T>, 
        IUnaryConvOp<ulong, T>,
		NumCIL.Generic.Operators.ITypeConversion
    {
<# if (typename == "Complex64") { #>
        /// <summary>
        /// Converts the input from a <see cref="System.Numerics.Complex"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(System.Numerics.Complex a) { return (T)a; }
<# } else { #>
        /// <summary>
        /// Converts the input from a <see cref="NumCIL.Complex64.DataType"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(NumCIL.Complex64.DataType a) { return (T)a; }
<# } #>

        /// <summary>
        /// Converts the input from a <see cref="System.Double"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(double a) { return (T)a; }

        /// <summary>
        /// Converts the input from a <see cref="System.Single"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(float a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.SByte"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(sbyte a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.Byte"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(byte a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.UInt16"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(ushort a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.Int16"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(short a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.UInt32"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(uint a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.Int32"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(int a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.UInt64"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(ulong a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.Int64"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(long a) { return (T)a; }
    }

    #endregion

    #region Complex conversion operators
    /// <summary>
    /// Operator for extracting the real component
    /// </summary>
    public struct Real : IUnaryConvOp<T, TComp>, NumCIL.Generic.Operators.IRealValue
    {
        /// <summary>
        /// Extracts the real component
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The real component valued</returns>
        public TComp Op(T a) { return a.Real; }
    }

    /// <summary>
    /// Operator for extracting the imaginary component
    /// </summary>
    public struct Imaginary : IUnaryConvOp<T, TComp>, NumCIL.Generic.Operators.IImaginaryValue
    {
        /// <summary>
        /// Extracts the imaginary component
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The imaginary component value</returns>
        public TComp Op(T a) { return a.Imaginary; }
    }

    /// <summary>
    /// Operator for extracting the magnitude component
    /// </summary>
    public struct Magnitude : IUnaryConvOp<T, TComp>
    {
        /// <summary>
        /// Extracts the magnitude component
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The magnitude component value</returns>
        public TComp Op(T a) { return a.Magnitude; }
    }

    /// <summary>
    /// Operator for extracting the phase component
    /// </summary>
    public struct Phase : IUnaryConvOp<T, TComp>
    {
        /// <summary>
        /// Extracts the phase component
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The phase component value</returns>
        public TComp Op(T a) { return a.Phase; }
    }

    /// <summary>
    /// Operator for calculating the conjugate
    /// </summary>
    public struct Conjugate : IUnaryOp<T>
    {
        /// <summary>
        /// Calculates the conjugate
        /// </summary>
        /// <param name="a">The input value</param>
        /// <returns>The conjugate value</returns>
        public T Op(T a) { return T.Conjugate(a); }
    }

    #endregion
}

<#
}
#>

namespace NumCIL.Boolean
{
    using T = System.Boolean;
    using InArray = NumCIL.Generic.NdArray<System.Boolean>;
    using OutArray = NdArray;

    /// <summary>
    /// A wrapper for a basic NdArray to a similar one with typed operators
    /// </summary>
	public partial class NdArray
	{
		#region Conversion operators
		/// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Double"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Double"/></returns>
        public static explicit operator NumCIL.Double.NdArray(OutArray a) { return UFunc.Apply<T, double, ToDouble>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Single"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Single"/></returns>
        public static explicit operator NumCIL.Float.NdArray(OutArray a) { return UFunc.Apply<T, float, ToFloat>(a); }
		/// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.SByte"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.SByte"/></returns>
        public static explicit operator NumCIL.Int8.NdArray(OutArray a) { return UFunc.Apply<T, sbyte, ToInt8>(a); }
		/// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Int16"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Int16"/></returns>
        public static explicit operator NumCIL.Int16.NdArray(OutArray a) { return UFunc.Apply<T, short, ToInt16>(a); }
		/// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Int32"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Int32"/></returns>
        public static explicit operator NumCIL.Int32.NdArray(OutArray a) { return UFunc.Apply<T, int, ToInt32>(a); }
		/// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Int64"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Int64"/></returns>
        public static explicit operator NumCIL.Int64.NdArray(OutArray a) { return UFunc.Apply<T, long, ToInt64>(a); }
		/// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Byte"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Byte"/></returns>
        public static explicit operator NumCIL.UInt8.NdArray(OutArray a) { return UFunc.Apply<T, byte, ToUInt8>(a); }
		/// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.UInt16"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.UInt16"/></returns>
        public static explicit operator NumCIL.UInt16.NdArray(OutArray a) { return UFunc.Apply<T, ushort, ToUInt16>(a); }
		/// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.UInt32"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.UInt32"/></returns>
        public static explicit operator NumCIL.UInt32.NdArray(OutArray a) { return UFunc.Apply<T, uint, ToUInt32>(a); }
		/// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.UInt64"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.UInt64"/></returns>
        public static explicit operator NumCIL.UInt64.NdArray(OutArray a) { return UFunc.Apply<T, ulong, ToUInt64>(a); }
		#endregion

		#region Conversion methods
		/// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Double"/>
        /// </summary>
        /// <param name="out">An optional output array</param>
        /// <returns>An NdArray of <see cref="System.Double"/></returns>
        public NumCIL.Double.NdArray ToDouble(NumCIL.Double.NdArray @out = null) { return UFunc.Apply<T, double, ToDouble>(this, @out); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Single"/>
        /// </summary>
        /// <param name="out">An optional output array</param>
        /// <returns>An NdArray of <see cref="System.Single"/></returns>
        public NumCIL.Float.NdArray ToFloat(NumCIL.Float.NdArray @out = null) { return UFunc.Apply<T, float, ToFloat>(this, @out); }
		/// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.SByte"/>
        /// </summary>
        /// <param name="out">An optional output array</param>
        /// <returns>An NdArray of <see cref="System.SByte"/></returns>
        public NumCIL.Int8.NdArray ToInt8(NumCIL.Int8.NdArray @out = null) { return UFunc.Apply<T, sbyte, ToInt8>(this, @out); }
		/// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Int16"/>
        /// </summary>
        /// <param name="out">An optional output array</param>
        /// <returns>An NdArray of <see cref="System.Int16"/></returns>
        public NumCIL.Int16.NdArray ToInt16(NumCIL.Int16.NdArray @out = null) { return UFunc.Apply<T, short, ToInt16>(this, @out); }
		/// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Int32"/>
        /// </summary>
        /// <param name="out">An optional output array</param>
        /// <returns>An NdArray of <see cref="System.Int32"/></returns>
        public NumCIL.Int32.NdArray ToInt32(NumCIL.Int32.NdArray @out = null) { return UFunc.Apply<T, int, ToInt32>(this, @out); }
		/// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Int64"/>
        /// </summary>
        /// <param name="out">An optional output array</param>
        /// <returns>An NdArray of <see cref="System.Int64"/></returns>
        public NumCIL.Int64.NdArray ToInt64(NumCIL.Int64.NdArray @out = null) { return UFunc.Apply<T, long, ToInt64>(this, @out); }
		/// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Byte"/>
        /// </summary>
        /// <param name="out">An optional output array</param>
        /// <returns>An NdArray of <see cref="System.Byte"/></returns>
        public NumCIL.UInt8.NdArray ToUInt8(NumCIL.UInt8.NdArray @out = null) { return UFunc.Apply<T, byte, ToUInt8>(this, @out); }
		/// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.UInt16"/>
        /// </summary>
        /// <param name="out">An optional output array</param>
        /// <returns>An NdArray of <see cref="System.UInt16"/></returns>
        public NumCIL.UInt16.NdArray ToUInt16(NumCIL.UInt16.NdArray @out = null) { return UFunc.Apply<T, ushort, ToUInt16>(this, @out); }
		/// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.UInt32"/>
        /// </summary>
        /// <param name="out">An optional output array</param>
        /// <returns>An NdArray of <see cref="System.UInt32"/></returns>
        public NumCIL.UInt32.NdArray ToUInt32(NumCIL.UInt32.NdArray @out = null) { return UFunc.Apply<T, uint, ToUInt32>(this, @out); }
		/// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.UInt64"/>
        /// </summary>
        /// <param name="out">An optional output array</param>
        /// <returns>An NdArray of <see cref="System.UInt64"/></returns>
        public NumCIL.UInt64.NdArray ToUInt64(NumCIL.UInt64.NdArray @out = null) { return UFunc.Apply<T, ulong, ToUInt64>(this, @out); }
		#endregion	
	}
		
	#region Conversion operators
    /// <summary>
    /// Operator for converting a value to <see cref="System.Single"/>
    /// </summary>
    public struct ToFloat : IUnaryConvOp<T, float>, NumCIL.Generic.Operators.ITypeConversion 
    { 
        /// <summary>
        /// Converts the input value to <see cref="System.Single"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public float Op(T a) { return (float)(a ? 1 : 0); } 
    }

    /// <summary>
    /// Operator for converting a value to <see cref="System.Double"/>
    /// </summary>
    public struct ToDouble : IUnaryConvOp<T, double>, NumCIL.Generic.Operators.ITypeConversion
    {
        /// <summary>
        /// Converts the input value to <see cref="System.Double"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public double Op(T a) { return (double)(a ? 1 : 0); } 
    }

    /// <summary>
    /// Operator for converting a value to <see cref="System.SByte"/>
    /// </summary>
    public struct ToInt8 : IUnaryConvOp<T, sbyte>, NumCIL.Generic.Operators.ITypeConversion 
    {
        /// <summary>
        /// Converts the input value to <see cref="System.SByte"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public sbyte Op(T a) { return (sbyte)(a ? 1 : 0); } 
    }

    /// <summary>
    /// Operator for converting a value to <see cref="System.Int16"/>
    /// </summary>
    public struct ToInt16 : IUnaryConvOp<T, short>, NumCIL.Generic.Operators.ITypeConversion
    {
        /// <summary>
        /// Converts the input value to <see cref="System.Int16"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public short Op(T a) { return (short)(a ? 1 : 0); } 
    }

    /// <summary>
    /// Operator for converting a value to <see cref="System.Int32"/>
    /// </summary>
    public struct ToInt32 : IUnaryConvOp<T, int>, NumCIL.Generic.Operators.ITypeConversion 
    {
        /// <summary>
        /// Converts the input value to <see cref="System.Int32"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public int Op(T a) { return (int)(a ? 1 : 0); } 
    }

    /// <summary>
    /// Operator for converting a value to <see cref="System.Int64"/>
    /// </summary>
    public struct ToInt64 : IUnaryConvOp<T, long>, NumCIL.Generic.Operators.ITypeConversion
    {
        /// <summary>
        /// Converts the input value to <see cref="System.Int64"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public long Op(T a) { return (long)(a ? 1 : 0); } 
    }

    /// <summary>
    /// Operator for converting a value to <see cref="System.Byte"/>
    /// </summary>
    public struct ToUInt8 : IUnaryConvOp<T, byte>, NumCIL.Generic.Operators.ITypeConversion 
    {
        /// <summary>
        /// Converts the input value to <see cref="System.Byte"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public byte Op(T a) { return (byte)(a ? 1 : 0); } 
    }

    /// <summary>
    /// Operator for converting a value to <see cref="System.UInt16"/>
    /// </summary>
    public struct ToUInt16 : IUnaryConvOp<T, ushort>, NumCIL.Generic.Operators.ITypeConversion 
    {
        /// <summary>
        /// Converts the input value to <see cref="System.UInt16"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public ushort Op(T a) { return (ushort)(a ? 1 : 0); } 
    }

    /// <summary>
    /// Operator for converting a value to <see cref="System.UInt32"/>
    /// </summary>
    public struct ToUInt32 : IUnaryConvOp<T, uint>, NumCIL.Generic.Operators.ITypeConversion 
    {
        /// <summary>
        /// Converts the input value to <see cref="System.UInt32"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public uint Op(T a) { return (uint)(a ? 1 : 0); } 
    }

    /// <summary>
    /// Operator for converting a value to <see cref="System.UInt64"/>
    /// </summary>
    public struct ToUInt64 : IUnaryConvOp<T, ulong>, NumCIL.Generic.Operators.ITypeConversion 
    {
        /// <summary>
        /// Converts the input value to <see cref="System.UInt64"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public ulong Op(T a) { return (ulong)(a ? 1 : 0); } 
    }	
	#endregion
}